- Class: meta
  Course: tidyswirl
  Lesson: tidyr
  Author: Matt Dray
  Type: Standard
  Version: 2.4.3

# Intro: package purpose

- Class: text
  Output: The {tidyr} package helps you make your dataset tidy.

- Class: text
  Output: Tabular data is 'tidy' if there's one variable per column and one row per observation. The tidyverse packages use tidy data for simplicity consistency. 

- Class: text
  Output: You're likely to use {tidyr} after you've read in your data with {readr} or {tibble} so you can prepare it for further manipulation with {dplyr}.

# Intro: relevant tidyverse cheatsheet

- Class: text
  Output: Get the RStudio cheatsheet for {tidyr} at https://github.com/rstudio/cheatsheets/blob/master/data-import.pdf

# Intro: package installation

- Class: cmd_question
  Output: You first need to install {tidyr} into your computer's package library. Run install.packages("tidyr"), or skip() if you've installed it before.
  CorrectAnswer: if (!require("tidyr")) install.packages("tidyr")
  AnswerTests: any_of_exprs('install.packages("tidyr")', 'install.packages(pkgs = "tidyr")', 'if (!require("tidyr")) install.packages("tidyr")', 'skip()')
  Hint: Remember to type quotation marks around "tidyr" when you pass it to the function.
  
- Class: cmd_question
  Output: Access {tidyr}'s functions by calling it from your computer's package library. Run library(tidyr).
  CorrectAnswer: library(tibble)
  AnswerTests: any_of_exprs('library("tidyr")', 'library(tidyr)', 'library(package = "tidyr")')
  Hint: Type the package name between the brackets of library(). You don't have to use quotation marks around the package name.

- Class: text
  Output: Great, the {tidyr} package is installed and loaded. Now we're going to look at some of the its functions.

# Group: reshaping data ---

- Class: text
  Output: We'll start with two functions -- gather() and spread() -- that will help reshape our data and make it tidy.

# Function: gather()

- Class: text
  Output: gather() helps us reshape a dataset from a 'wide' format to a 'long' format.

- Class: cmd_question
  Output: The {tidyr} package has a built-in dataset that's wide and untidy. Type 'table4a' and hit enter to see it
  CorrectAnswer: tidy4a
  AnswerTests: omnitest(correctVal = 'table4a')
  Hint: Type 'table4a' (without quotation marks) and hit enter.

- Class: text 
  Output: Did you notice the yearly data is in separate columns (1999 and 2000)? This means the data is wide -- it has two observations per row -- and is therefore untidy. The gather() function will help us fix this.

- Class: text
  Output: gather() needs four things -- (1) the data frame name (table4a), (2) the columns to be gathered (`1999`, `2000`), (3) the 'key' argument, a name ("year") for the column we're gathering into, and (4) the 'value' argument, a new name ("cases") for the new data column. 

- Class: cmd_question
  Output: Use the gather() function to make table4a tidy.
  CorrectAnswer: gather(table4a, `1999`, `2000`, key = "year", value = "cases")
  AnswerTests: omnitest(correctVal = 'gather(table4a, `1999`, `2000`, key = "year", value = "cases")')
  Hint: Use the form gather(dataframe, column_to_gather1, column_to_gather2, key = "col_name", value = "col_name")

- Class: text
  Output: Excellent, gather() helped tidy the data from wide to long format.

# Function: spread()

- Class: text
  Output: The second {tidyr} function for reshaping data is spread(). It does the opposite to gather() -- it helps us reshape from a 'long' to a 'wide' format.

- Class: text
  Output: For example, we might have multiple rows for the same observation. For each country-year combination we might have a column with two different types of data in it that should really be in separate columns. Let's take a look at an example.

- Class: cmd_question
  Output: The {tidyr} package has a built-in dataset that's long and untidy. Type 'table2' and hit enter to see it
  CorrectAnswer: tidy2
  AnswerTests: omnitest(correctVal = 'table2')
  Hint: Type 'table2' (without quotation marks) and hit enter.

- Class: text
  Output: Did you notice the 'type' column and its corresponding 'count' column contain two types of data ('cases' and 'population')? We need to spread the unique values of 'type' into separate columns filled with the 'count' data.

- Class: text
  Output: To do this, you need to give spread() three things -- (1) the name of the data frame (table2a), (2) the name of the column (type) whose unique values will become new columns, and (3) the name of the column (count) that has the data that will fill the new columns.

- Class: cmd_question
  Output: Use the spread() function to make table2 tidy.
  CorrectAnswer: gather(table2, type, count)
  AnswerTests: omnitest(correctVal = 'spread(table2, type, count)')
  Hint: Use the form spread(dataframe_name, column_to_spread, column_of_data).

- Class: text
  Output: Excellent, spread() helped tidy the data from long to wide format.

# Test: group

- Class: mult_question
  Output: Which of these are properties of 'tidy' data? (A) Thre's one row per observation, (B) there's one column per variable (C) long data is tidier than wide data, (D) wide data is tidier than long data.
  AnswerChoices: All of them; (A) and (B); (A), (B) and (C); (A), (B) and (D); (A) only
  CorrectAnswer: (A) and (B)
  AnswerTests: omnitest(correctVal='(A) and (B)')
  Hint: gather() makes wide data long and spread() does the opposite. Both create the right number of columns to allow for a single observation per row. 

- Class: text
  Output: Okay, we're done with reshaping for now. Let's take a look at some simpler functions from {tidyr} that will help prepare data for further analysis. 

# Group: deal with missing values ---

- Class: text
  Output: Often your dataset will have missing values. How can you treat these?

- Class: cmd_question
  Output: I've added a table with NAs (missing values) to your environment. Run 'table_na' to print the table.
  CorrectAnswer: table_na
  AnswerTests: omnitest(correctVal = 'table_na')
  Hint: Type 'table_na' and press enter to see the table in the console.

- Class: text
  Output: The table has two columns and five rows. Column x2 has a mixture of data and missing values (NA).

# Function: drop_na()

- Class: text
  Output: drop_na() lets you discard rows that contain an NA by supplying the name of the data frame and the column containing NA values.

- Class: cmd_question
  Output: Use drop_na() to remove the rows of table_na that contain an NA in the x2 column.
  CorrectAnswer: drop_na(table_na, x2)
  AnswerTests: omnitest(correctVal = 'drop_na(table_na, x2)')
  Hint: Type 'table_na' and 'x2' into the brackets of drop_na() separated by a comma.

# Function: replace_na()

- Class: text
  Output: replace_na() lets you swap NA values for another value. You supply (1) the name of the data frame and (2) a list containing the column to convert and value to replace NAs with, in the form list(col_name = "replacement_value").

- Class: cmd_question
  Output: Use replace_na() to convert the NA values in the x2 column of table_na to a 1.
  CorrectAnswer: replace_na(table_na, list(x2 = 1))
  AnswerTests: omnitest(correctVal = 'replace_na(table_na, list(x2 = 1))')
  Hint: Supply table_na as the first argument to replace_na() and list(x2 = 1) as the second argument.

# Function: fill()

- Class: text
  Output: The fill() function will replace NAs in a column with the the closest valid value above it.

- Class: cmd_question
  Output: Use fill() to 'fill down' the x2 column and replace the NAs.
  CorrectAnswer: fill(table_na, x2)
  AnswerTests: omnitest(correctVal = 'fill(table_na, x2)')
  Hint: Pass table_na as the first argument to fill() and x2 as the second argument.

# Test: group

# Group: splitting data ---

- Class: text
  Output: Sometimes multiple data items are stored in the same 'cell' of a data frame, which is untidy. {tidyr} can help split these items into new columns or rows.

- Class: cmd_question
  Output: Run table3 to see an example of a table that needs separation.
  CorrectAnswer: table3
  AnswerTests: omnitest(correctVal = 'table3')
  Hint: Type 'table3' and press enter to see the table in the console.

- Class: text
  Output: The 'rate' column contains two data items with a forward slash ('/') between them.

# Function: separate()

- Class: text
  Output: The separate() function splits data by some delimiter and puts each part into its own column. Supply (1) the data frame name, (2) the column that needs separating, (3) the delimiter, (4) a vector of column names to received the separated data.

- Class: cmd_question
  Output: Use separate on table3 to split the 'rate' column by '/' into new columns named 'cases' and 'pop'.
  CorrectAnswer: separate(table3, rate, sep = "/", into = c("cases", "pop"))
  AnswerTests: any_of_exprs('separate(table3, rate, into = c("cases", "pop"))', 'separate(table3, rate, "/", into = c("cases", "pop"))', 'separate(table3, rate, sep = "/", into = c("cases", "pop"))')
  Hint: Use the form separate(dataframe, col_to_separate, sep = "/", into = c("new_col_1", "new_col_2"))

# Function: separate_rows()

- Class: text
  Output: The separate_rows() function is like separate(), but the separated data are inserted into new rows rather than new columns. This means you only need to supply (1) the data frame name, (2) the name of the column to be separated into rows and (3) in the form sep = "/".

- Class: cmd_question
  Output: Use separate_rows() on table3 to split the 'rate' column by '/' into new rows.
  CorrectAnswer: separate_rows(table3, rate, sep = "/")
  AnswerTests: omnitest(correctVal = 'separate_rows(table3, rate, sep = "/")')
  Hint: Your answer should be in the form separate_rows(dataframe, col_to_separate, sep = "/")

# Function: unite()

- Class: text
  Output: We can also unite() columns, which is the opposite of separating them. You pass (1) the name of the data frame, (2) the columns from which data will be united, (3) the delimiter, (4) a name for the column that will hold the newly-united data. 

- Class: cmd_question
  Output: Use unite() on table5 to combine the 'century' and 'year' columns with a blank delimiter ("") into a new column ("year").
  CorrectAnswer: unite(table5, century, year, sep = "", col = "year")
  AnswerTests: omnitest(correctVal = '')
  Hint: Your answer should be in the form unite(dataframe, col_to_unite_1, col_to_unite_2, sep = "/", col = "new_col")

# Test: group

# Group: expand tables
# Function: complete()
# Function: expand()
# Test: group

# Group: List-columns
# Function: nest()
# Function: unnest()
# Test: group

# Test knowledge of package

# Outro: 
